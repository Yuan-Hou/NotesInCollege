- [1. 快读](#1-快读)
  - [1.1. 常规](#11-常规)
  - [1.2. 高级加速](#12-高级加速)
- [2. 快写](#2-快写)
- [3. C++解绑流](#3-c解绑流)
- [4. 并查集](#4-并查集)
- [5. 链式前向星](#5-链式前向星)
  - [5.1. 初始化](#51-初始化)
  - [5.2. 加边](#52-加边)
  - [5.3. 遍历](#53-遍历)
- [6. 归并和逆序对](#6-归并和逆序对)
- [7. 二分查找](#7-二分查找)
- [8. 单调队列](#8-单调队列)
- [9. 0/1背包](#9-01背包)
- [10. 钢条切割](#10-钢条切割)
- [11. 傅里叶变换](#11-傅里叶变换)
- [12. 最大流最小割](#12-最大流最小割)
- [13. 最短路径](#13-最短路径)
  - [13.1. 迪杰斯科拉(要路径)](#131-迪杰斯科拉要路径)
  - [13.2. 迪杰斯科拉(求众多距离)](#132-迪杰斯科拉求众多距离)
  - [13.3. 佛洛依德](#133-佛洛依德)
- [14. 找欧拉圈](#14-找欧拉圈)
- [15. 凸包](#15-凸包)
- [16. 字符串匹配](#16-字符串匹配)
  - [16.1. 有限状态机](#161-有限状态机)
  - [16.2. KMP](#162-kmp)
- [17. 树状数组](#17-树状数组)
- [18. 线段树](#18-线段树)
  - [18.1. 定义](#181-定义)
  - [18.2. 建树](#182-建树)
  - [18.3. 点修改](#183-点修改)
    - [18.3.1. 点修改下的区间查询](#1831-点修改下的区间查询)
  - [18.4. 区间修改](#184-区间修改)
    - [18.4.1. 区间修改下的区间查询](#1841-区间修改下的区间查询)
- [19. 字符串哈希](#19-字符串哈希)
- [20. 树状数组](#20-树状数组)
- [21. 旋转卡壳](#21-旋转卡壳)
- [22. 迪杰斯科拉](#22-迪杰斯科拉)
- [23. 最大拓扑排序](#23-最大拓扑排序)
  - [23.1. 判断环路](#231-判断环路)
- [24. 我的最大流](#24-我的最大流)
- [25. 波动数组](#25-波动数组)
- [26. 完全背包](#26-完全背包)
- [27. 最优二叉搜索树最小搜索代价](#27-最优二叉搜索树最小搜索代价)
- [28. 最长公共子序列](#28-最长公共子序列)
- [29. 最小生成树](#29-最小生成树)
  - [29.1. 普利姆](#291-普利姆)
- [30. 克鲁斯卡尔](#30-克鲁斯卡尔)
- [31. 交叉线段的数量](#31-交叉线段的数量)
- [32. 检查两线段是否相交](#32-检查两线段是否相交)

# 1. 快读
## 1.1. 常规
```c++
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
```
## 1.2. 高级加速
```c++
char buf[1<<15],*fs,*ft;
inline char gc(){
    return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;}

inline int gint(){
    int x=0,f=1,ch=gc();
    while(ch<'0'||ch>'9'){if (ch=='-')    f=-1;    ch=gc();}
    while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=gc();
    return x*f;
}
// 使用gint读取数据
// int x = gint();
// 注意，由于实现机制特殊，这个板子只适用于输入只有数字的情况，如果输入中含有字符或字符串
//需要处理，请勿使用
```

# 2. 快写

```c++
inline void Write(int x) {
    static int sta[15];
    if (x<0)    {putchar('-');    x=-x;}
      register int top=0;
      do{
        sta[top++]=x%10,x/=10;
      }while (x);
      while (top) putchar(sta[--top]+48);
}
```

# 3. C++解绑流

```c++
std::ios::sync_with_stdio(false);
std::cin.tie(0);
```

# 4. 并查集

```c++
#include <bits/stdc++.h>
using namespace std;
int n,m,z,x,y,fa[10005];//fa[i]是第i号节点的祖先
inline int find(int x)
{
    while(x!=fa[x]) x=fa[x]=fa[fa[x]];
    //让x和x的父亲变成他的父亲的父亲
    //直到找到祖先才结束循环(x==fa[x])就意味着找到爹了
    return x;
}
//循环版找爹函数
/*
//再附上递归版本的找爹函数
inline int find(int x) 
{
    if (x==fa[x]) return x;
    //不停的递归查找
    return fa[x]=find(fa[x]);
    //路径压缩，可以缩短时间
}
*/
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;++i) 
    {
    	fa[i]=i;
        //并查集的初始化
    }
    while(m--)
    {
        cin>>z>>x>>y;
        int a=find(x),b=find(y);
        //ab分别去找自己的爹
        if(z==1)
        {
        	fa[a]=b;
            //并查集的合并操作，及将x点祖先的爹记为y点的祖先
        }
        if(z==2)
        {
            if(a==b) 
            {
            	puts("Y");
                //爹一样就说明X与Y是在同一集合内，输出Y
            }
            else 
            {
            	puts("N");
                //否则就说明X与Y是在同一集合内，输出N
            }
        } 
    }
    return 0;
}
```

# 5. 链式前向星

## 5.1. 初始化
```C++
const int maxn = 100;
struct Edge {
    int to, w, next;  // to代表边的终点，w代表边的权值，next下面加边的时候更清楚
}edge[maxn];          // 边数组
int head[maxn];       // head数组

int cnt, n = 5, m = 7; // n为结点数量，m为边数
void init() {
    for(int i = 0; i <= 5; ++i) 
        head[i] = -1;  // head初始都为-1
    cnt = 0;
};
```
## 5.2. 加边
```c++
void add_edge(int u, int v, int w) {
    edge[cnt].to = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt++;
}
```
## 5.3. 遍历
```c++
for(int i = 1; i <= n; ++i) {
    for(int j = head[i]; ~j; j = edge[j].next) {
        cout << "start=" << i << " to=" << edge[j].to << " w=" << edge[j].w << endl;
    }
}
```
# 6. 归并和逆序对

```c
#include<stdio.h>
int temp[2000000];
int K[2000000];
long long count;
unsigned long long ret = 0;
void merge(int *l1,int l1Size,int *l2,int l2Size){
    int i, j, k;
    i = j = k = 0;
    while(i<l1Size&&j<l2Size){
        if(l1[i]<=l2[j]){
            temp[k] = l1[i];
            i++;
            k++;
        }else{
            temp[k] = l2[j];
            j++;
            k++;
            ret += l1Size - i;
        }
    }
    while(i<l1Size){
        temp[k++] = l1[i++];
    }
    while(j<l2Size){
        temp[k++] = l2[j++];
    }
    for (int m = 0; m < l1Size + l2Size;++m){
        l1[m] = temp[m];
    }
}
void mergeSort(int* k,int n){
    if(n>1){
        int *l1 = k;
        int l1s = n / 2;
        int *l2 = k + l1s;
        int l2s = n - l1s;
        mergeSort(l1,l1s);
        mergeSort(l2,l2s);
        merge(l1,l1s,l2,l2s);
    }
}
int main(){
    scanf("%d",&count);
    for (int i = 0; i < count;++i)
    {
        scanf("%d",K+i);
    }
    mergeSort(K,count);
    printf("%lld",ret);
}
```

# 7. 二分查找
```C
int findFirst(int len,int k){
    int l = 0;
    int r = len - 1;
    while (l<r)
    {
        int m = (l + r) / 2;
        if(a[m]>=k){
            r = m;
        }else{
            l = m + 1;
        }
    }
    if(a[l]!=k)
        return -1;
    return l;
}

int findLast(int len,int k){
    int l = 0;
    int r = len - 1;
    while (l<r)
    {
        int m = (l + r) / 2+1;
        if(a[m]>k){
            r = m-1;
        }else{
            l = m ;
        }
    }
    if(a[l]!=k)
        return -1;
    return l;
}
```

# 8. 单调队列

```c++
#include<cstdio>
#include<cstring>
using namespace std; 

struct Monotone_queue
{
    static const int maxn=1000001;
    int n,k,a[maxn];
    int q[maxn],head,tail,p[maxn];//同题目叙述一样，q是单调队列，p是对应编号。
    
    void read()
    {
        scanf("%d %d",&n,&k);
        for(int i=1;i<=n;++i)
            scanf("%d",&a[i]);
    }//读入不必说了
    
    void monotone_max()//单调最大值
    {
        head=1;
        tail=0;
        for(int i=1;i<=n;++i)
        {
            while(head<=tail&&q[tail]<=a[i])
                tail--;
            q[++tail]=a[i];
            p[tail]=i;
            while(p[head]<=i-k)
                head++;
            if(i>=k)printf("%d ",q[head]);
        }
        printf("\n");
    }
    
    void monotone_min()
    {
        head=1;
        tail=0;//为啥要这样呢?因为head要严格对应首元素，tail要严格对应尾元素，
        //所以当tail>=head时，说明有元素。而一开始队列为空，说一要这样赋值。其实这跟普通队列一样。
        for(int i=1;i<=n;++i)
        {//a[i]表示当前要处理的值
            while(head<=tail&&q[tail]>=a[i])
                tail--;
                //只要队列里有元素，并且尾元素比待处理值大，即表示尾元素已经不可能出场，
                //所以出队。直到尾元素小于待处理值，满足"单调"。
            q[++tail]=a[i];//待处理值入队。
            p[tail]=i;//同时存下其编号
            while(p[head]<=i-k)
                head++;//如果队首元素已经"过时"，出队。
            if(i>=k)printf("%d ",q[head]);//输出最值，即队首元素。i>=k表示该输出，至于why就自己看题目。
        }
        printf("\n");
        
    }
}worker;

int main()
{
    worker.read();
    worker.monotone_min();
    worker.monotone_max();
    return 0;
}
```

# 9. 0/1背包

递推关系式：

① j<w(i)      V(i,j)=V(i-1,j)            只是为了好理解，可以不用写，不会影响结果。

② j>=w(i)     V(i,j)=max｛ V(i-1,j)，V(i-1,j-w(i))+v(i) ｝

dp[i][j]以j为容量为放入前i个物品(按i从小到大的顺序)的最大价值

```c++
//求解将哪些物品装入背包可使这些物品的重量总和不超过背包承重量t，且价值总和最大。
#include <stdio.h>
#include <string.h>
 
int f[1010],w[1010],v[1010];
//f记录不同承重量背包的总价值，w记录不同物品的重量，v记录不同物品的价值
 
int max(int x,int y){//返回x,y的最大值
    if(x>y) return x;
    return y;
}
 
int main(){
    int t,m,i,j;
    memset(f,0,sizeof(f));  //总价值初始化为0
    scanf("%d %d",&t,&m);  //输入背包承重量t、物品的数目m
    for(i=1;i<=m;i++)
        scanf("%d %d",&w[i],&v[i]);  //输入m组物品的重量w[i]和价值v[i]
    for(i=1;i<=m;i++){  //尝试放置每一个物品
        for(j=t;j>=w[i];j--){//倒叙是为了保证每个物品都使用一次
            f[j]=max(f[j-w[i]]+v[i],f[j]);
            //在放入第i个物品前后，检验不同j承重量背包的总价值，
            //如果放入第i个物品后比放入前的价值提高了，则修改j承重量背包的价值，否则不变
        }
    }
    printf("%d",f[t]);  //输出承重量为t的背包的总价值
    printf("\n");
    getch();
    return 0;
}
```

# 10. 钢条切割

```C++
int bottomUpCutRod(int pro[], int r[], int n)
{
    for (int i = 1; i <= n; i++)
    {
        int profit = 0;
        for (int j = 1; j <= i; j++)
            profit = max(profit, pro[j] + r[i - j]);
        r[i] = profit;
    }
    return r[n];
}
```

# 11. 傅里叶变换

```c++
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
const int MAXN=2*1e6+10;
inline int read()
{
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const double Pi=acos(-1.0);
struct complex
{
    double x,y;
    complex (double xx=0,double yy=0){x=xx,y=yy;}
}a[MAXN],b[MAXN];
complex operator + (complex a,complex b){ return complex(a.x+b.x , a.y+b.y);}
complex operator - (complex a,complex b){ return complex(a.x-b.x , a.y-b.y);}
complex operator * (complex a,complex b){ return complex(a.x*b.x-a.y*b.y , a.x*b.y+a.y*b.x);}
//不懂的看复数的运算那部分 
void fast_fast_tle(int limit,complex *a,int type)
{
    if(limit==1) return ;//只有一个常数项
    complex a1[limit>>1],a2[limit>>1];
    for(int i=0;i<=limit;i+=2)//根据下标的奇偶性分类
        a1[i>>1]=a[i],a2[i>>1]=a[i+1];
    fast_fast_tle(limit>>1,a1,type);
    fast_fast_tle(limit>>1,a2,type);
    complex Wn=complex(cos(2.0*Pi/limit) , type*sin(2.0*Pi/limit)),w=complex(1,0);
    //Wn为单位根，w表示幂
    for(int i=0;i<(limit>>1);i++,w=w*Wn)//这里的w相当于公式中的k 
        a[i]=a1[i]+w*a2[i],
        a[i+(limit>>1)]=a1[i]-w*a2[i];//利用单位根的性质，O(1)得到另一部分 
}
int main()
{
    int N=read(),M=read();
    for(int i=0;i<=N;i++) a[i].x=read();
    for(int i=0;i<=M;i++) b[i].x=read();
    int limit=1;while(limit<=N+M) limit<<=1;
    fast_fast_tle(limit,a,1);
    fast_fast_tle(limit,b,1);
    //后面的1表示要进行的变换是什么类型
    //1表示从系数变为点值
    //-1表示从点值变为系数 
    //至于为什么这样是对的，可以参考一下c向量的推导过程， 
    for(int i=0;i<=limit;i++)
        a[i]=a[i]*b[i];
    fast_fast_tle(limit,a,-1);
    for(int i=0;i<=N+M;i++) printf("%d ",(int)(a[i].x/limit+0.5));
    //按照我们推倒的公式，这里还要除以n 
    return 0;
}
```

# 12. 最大流最小割

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const int N = 10010, E = 200010;

int n, m, s, t; LL ans = 0;
LL cnt = 1, first[N], nxt[E], to[E], val[E];
inline void addE(int u, int v, LL w) {
	to[++cnt] = v;
	val[cnt] = w;
	nxt[cnt] = first[u];
	first[u] = cnt;
}
int dep[N], q[N], l, r;
bool bfs() {//顺着残量网络，方法是 bfs；这是个bool型函数，返回是否搜到了汇点 
	memset(dep, 0, (n + 1) * sizeof(int));//记得开局先初始化 

	q[l = r = 1] = s;
	dep[s] = 1;
	while(l <= r) {
		int u = q[l++];
		for(int p = first[u]; p; p = nxt[p]) {
			int v = to[p];
			if(val[p] and !dep[v]) {//按照有残量的边搜过去 
				dep[v] = dep[u] + 1;
				q[++r] = v;
			}
		}
	}
	return dep[t];//dep[t] != 0，就是搜到了汇点 
}
LL dfs(int u, LL in/*u收到的支持（不一定能真正用掉）*/) {
//注意，return 的是真正输出的流量
	if(u == t)
		return in;//到达汇点是第一个有效return 
	LL out = 0;
	for(int p = first[u]; p and in; p = nxt[p]) {
		int v = to[p];
		if(val[p] and dep[v] == dep[u] + 1) {//仅允许流向下一层 
			LL res = dfs(v, min(val[p], in)/*受一路上最小流量限制*/);
			//res是v真正输出到汇点的流量
			val[p] -= res;
			val[p ^ 1] += res;
			in -= res;
			out += res;
		}
	}
	if(out == 0)//我与终点（顺着残量网络）不连通 
		dep[u] = 0;//上一层的点请别再信任我，别试着给我流量
	return out;
}
int main() {
	scanf("%d %d %d %d", &n, &m, &s, &t);
	for(int i = 1; i <= m; ++i) {
		int u, v; LL w;
		scanf("%d %d %lld", &u, &v, &w);
		addE(u, v, w);
		addE(v, u, 0);
	}
	while(bfs()) 
		ans += dfs(s, 1e18);
	printf("%lld\n", ans);
	return 0;
}
```
# 13. 最短路径

## 13.1. 迪杰斯科拉(要路径)
```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
const int MAXV = 201;
const int INF = 0x3fffffff;
//邻接矩阵版本
int n, m, s;
int G[MAXV][MAXV];
int d[MAXV];  //各个点到出发点的最短路径
bool Vis[MAXV] = { false };
//并查集输出最短路径
int f[MAXV];
 
void Dijkstra(int s) {   //起始点
	fill(d, d + MAXV, INF);
	d[s] = 0;  //不管什么情况一定要初始化
	for (int i = 0; i < n; ++i) {
		//寻找最小的点
		int u = -1, MIN = INF;
		for (int j = 0; j < n; ++j) {
			if (!Vis[j] && d[j] < MIN) {
				MIN = d[j];
				u = j;
			}
		}
		if (u == -1) return;   //所有边访问完成,算法完成,退出
		//更新每个结点的最小距离
		Vis[u] = true;  //设置本结点为访问结点
		for (int v = 0; v < n; ++v) {
			if (!Vis[v] && G[u][v] != INF && G[u][v] + d[u] < d[v]) {
				d[v] = G[u][v] + d[u];  //优化结点
				f[v] = u;  //并查集
			}
		}
	}
}
void getRoute(int e) { //如果要求路径的话,可以用并查集实现
	cout << e;
	if (f[e] != e) {
		cout << " ";
		getRoute(f[e]); 
	}
}
int main() {
	fill(G[0], G[0] + MAXV * MAXV, INF); //切记一定要赋初值
	int u, v, w;
	for (int i = 0; i < MAXV; ++i) {
		f[i] = i;  //并查集更新
	}
	scanf("%d %d %d", &n, &m, &s);
	for (int i = 0; i < m; ++i) {
		scanf("%d %d %d", &u, &v, &w);
		G[u][v] = w;
	}
 
	Dijkstra(s);  //起始点
	for (int i = 0; i < n; ++i) {
		printf("%d\n", d[i]);
		getRoute(i);
		cout << endl;
	}
 
	system("PAUSE");
	return 0;
}
```

## 13.2. 迪杰斯科拉(求众多距离)

```C++
// Author: Alex
#include <bits/stdc++.h>

using namespace std;
const int N = 100100;

int n, m, num, dis1[N], dis2[N];
vector<pair<int, int>> G[N];

bool vis[N];
priority_queue<pair<int, int>> pq; 
void dijkstra(int s, int n, int *dis) {
    for (int i = 1;i <= n; ++i) 
        dis[i] = 0x3f3f3f3f, vis[i] = false;
    dis[s] = 0; pq.emplace(-dis[s], s);
    while (!pq.empty()) {
        auto [w, u] = pq.top(); pq.pop();
        if (vis[u]) continue;
        vis[u] = true;
        for (auto &&[v, w] : G[u]) if (dis[u] + w < dis[v]) {
            dis[v] = dis[u] + w;
            pq.emplace(-dis[v], v);
        } 
    }
}

int main() {
    cin >> n >> m >> num;
    for (int i = 1, u, v, w;i <= m; ++i) {
        cin >> u >> v >> w;
        G[u].emplace_back(v, w);
        G[v].emplace_back(u, w);
    }
    dijkstra(1, n, dis1);
    dijkstra(n, n, dis2);
    int ans = 0x3f3f3f3f;
    while (num--) {
        int x; cin >> x;
        ans = min(ans, dis1[x] + dis2[x]);
    }
    cout << dis1[n] << endl;
    return 0;
}
```

## 13.3. 佛洛依德

```C++
for(int i=1;i<=n;i++){
   for(int j=1;j<=n;j++){
      if(edge[i][j]>edge[i][1]+edge[1][j]){
         edge[i][j]=edge[i][1]+edge[1][j];
      }
   }
}
```

# 14. 找欧拉圈

```c++
#include<bits/stdc++.h>
#define toUpper(a) ((a>='a'&&a<='z')?a-'a'+'A':a)
using namespace std;

class Graph{
    int V;
    list<int> *adj;
    int *in;
public:
    Graph(int V);
    ~Graph() { 
        delete[] adj;
        delete[] in;
    }
    void addEdge(int v,int w){
        adj[v].push_back(w);
        (in[w])++;
    }
    bool isEulerianCycle();
    void getEulerianCycle(vector<int>& ret);
    bool isSC();//if it's fully connecyed
    void DFSUtil(int v,bool visited[]);//used by isSC
    Graph getTranspose();
    
};
Graph::Graph(int V){
    this->V = V;
    adj = new list<int>[V];
    in = new int[V];
    for (int i = 0; i < V;++i)
    {
        in[i] = 0;
    }
}
bool Graph::isEulerianCycle(){
    if(isSC()== false){
        return false;
    }
    for (int i = 0; i < V;++i)
        if(adj[i].size()!=in[i])
            return false;
    return true;
}
void Graph::DFSUtil(int v,bool visited[]){
    visited[v] = true;
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end();++i)
        if(!visited[*i])
            DFSUtil(*i,visited);
}
Graph Graph::getTranspose(){
    Graph g(V);
    for (int v = 0; v < V;++v)
    {
        for (auto i = adj[v].begin(); i != adj[v].end();++i)
        {
            g.adj[*i].push_back(v);
            (g.in[v])++;
        }
    }
    return g;
}
bool Graph::isSC(){
    bool visited[V];
    for (int i = 0; i < V;++i)
    {
        visited[i] = false;
    }
    int n;
    for (n = 0; n < V;++n)
        if(adj[n].size()>0)
            break;
    DFSUtil(n,visited);
    for (int i = 0; i < V;++i)
        if(adj[i].size()>0&&visited[i] == false)
            return false;
    Graph gr = getTranspose();
    for (int i = 0; i < V;++i)
    {
        visited[i] = false;
    }
    gr.DFSUtil(n,visited);
    for (int i = 0; i < V;++i)
        if(adj[i].size()>0&&visited[i] == false)
            return false;
    return true;
}

void Graph::getEulerianCycle(vector<int>& ret){
    stack<int> curr_path;
    int curr_v, next_v;
    for (int n = 0; n < V;++n)
        if(adj[n].size()>0){
            curr_path.push(n);
            curr_v = n;
            //ret.push_back(n);
            break;
        }
    while(!curr_path.empty()){
        if(!adj[curr_v].empty()){
            curr_path.push(curr_v);
            next_v = adj[curr_v].back();
            adj[curr_v].pop_back();
            curr_v = next_v;
        }else{
            ret.push_back(curr_v);
            curr_v = curr_path.top();
            curr_path.pop();
        }
    }
}
vector<string> Map[26][26];

char temp[100];

int main(){
    int n;
    Graph g(26);
    scanf("%d",&n);
    int from, to;
    for (int i = 0; i < n;++i)
    {
        scanf(" %s",temp);
        int l = strlen(temp);
        from = (temp[0] >= 'a' && temp[0] <= 'z') ? temp[0] - 'a' : temp[0] - 'A';
        to = (temp[l-1] >= 'a' && temp[l-1] <= 'z') ? temp[l-1] - 'a' : temp[l-1] - 'A';
        temp[l - 1] = 0;
        Map[from][to].push_back(string(temp+1));
        g.addEdge(from,to);
    }
    if(!g.isEulerianCycle()){
        printf("None");
        return 0;
    }
    vector<int> rpath;
    g.getEulerianCycle(rpath);
    for (auto i = rpath.rbegin(); i != rpath.rend()-1;++i)
    {
        from = *i;
        to = *(i+1);
        printf("%c%s",'A'+from,Map[from][to].back().c_str());
        Map[from][to].pop_back();
    }
    printf("%c",'A'+to);
}
```

# 15. 凸包

```c++
#include<bits/stdc++.h>
using namespace std;
const double eps = 1e-8;

class Point
{

    static bool cmpForConvex(const Point &a, const Point &b); //凸包算法用
    
    public:
    
    double x,y;
    Point();
    Point(double x, double y);
    Point operator+(const Point &a) const;
    
    Point operator -(const Point&a)const;
    Point operator*(const double &a) const;
    double operator*(const Point &a) const;
    double operator^(const Point &a) const;
    inline double normSq();

    inline static void convexClosure(vector<Point> &ps, vector<Point> &ret);
};
Point p0;//凸包算法用
int dcmp(double x)
{
    if(fabs(x)<=eps)return 0;
    return x>0?1:-1;
}


    
bool Point::cmpForConvex(const Point& a,const Point& b){//凸包算法用
    double x = (a - p0) ^ (b - p0);
    if(x>0)
        return 1;
    if(x == 0&&(a-p0).normSq()<(b-p0).normSq())
        return 1;
    return 0;
}
Point::Point(){}
Point::Point(double x,double y):x(x),y(y){}
Point Point::operator +(const Point&a)const{return Point(x+a.x,y+a.y);}
Point Point::operator -(const Point&a)const{return Point(x-a.x,y-a.y);}
Point Point::operator *(const double&a)const{return Point(x*a,y*a);}
double Point::operator *(const Point&a)const{return x*a.x+y*a.y;}
double Point::operator ^(const Point&a)const{return x*a.y-y*a.x;}
inline double Point::normSq(){
    return *this * *this;
}


inline void Point::convexClosure(vector<Point>& ps,vector<Point>& ret){
    if(ps.size()<3){
        return;
    }
    p0 = ps[0];
    auto p0i = ps.begin();
    for (auto i = ps.begin() + 1; i != ps.end();++i)
    {
        if(p0.y>i->y){
            p0 = *i;
            p0i = i;
        }
    }
    *p0i = ps[0];
    ps[0] = p0;
    ret.push_back(p0);
    sort(ps.begin()+1,ps.end(),cmpForConvex);
    ret.push_back(ps[1]);
    ret.push_back(ps[2]);
    for (auto i = ps.begin() + 3; i != ps.end();++i)
    {
        while(ret.size()>2&&((ret.back()-*(ret.end()-2))^(*i-ret.back()))<=0)
            ret.pop_back();
        ret.push_back(*i);
    }
}

typedef Point Vector;
class Line
{
    public:
    Point p1,p2;
    Vector v;
    Line(){}
    Line(Point P1, Vector P2) : p1(P1), p2(P2) { v = P2 - P1; }
    Line(double x1,double y1,double x2,double y2){
        p1.x = x1;
        p1.y = y1;
        p2.x = x2;
        p2.y = y2;
        v = p2 - p1;
    }
    Line(istream& s){
        s >> p1.x >> p1.y >> p2.x >> p2.y;
        v = p2 - p1;
    }
    enum RelationToLine
    {
        LineLap,
        PointCross,
        NoneCross
    };
    enum RelationToPoint
    {
        ClockWise = -1,
        CounterClockWise = 1,
        OnLineBack = 2,
        OnLineFront = -2,
        OnSegment = 0
    };
    Line operator-() const{
        return Line(p2,p1);
    }
    RelationToPoint judgePoint(Point p){
        Vector w = p - p1;
        char r1 = dcmp(v ^ w);
        if(r1 == 1)
            return CounterClockWise;
        if(r1 == -1)
            return ClockWise;
        if(dcmp(v*w)==-1)
            return OnLineBack;
        if(v.normSq()<w.normSq())
            return OnLineFront;
        return OnSegment;
    }
    bool intersect(Line l){
        return (judgePoint(l.p1) * judgePoint(l.p2) <= 0) && 
        (l.judgePoint(p1) * l.judgePoint(p2) <= 0);
    }
    
};
int main(){
    ios::sync_with_stdio(false);
    vector<Point> ps, ret;
    int n;
    cin >> n;
    Point buf;
    for (int i = 0; i < n;++i)
    {
        cin >> buf.x >> buf.y;
        ps.push_back(buf);
    }
    Point::convexClosure(ps,ret);
    double result = 0;
    for (auto i = ret.begin()+1; i != ret.end();++i)
    {
        result += sqrt((*i-*(i-1)).normSq());
    }
    result += sqrt((*(ret.end()-1)-*ret.begin()).normSq());
    cout<<setiosflags(ios::fixed)<<setprecision(2);
    cout<<result<<endl;
}
```

# 16. 字符串匹配

## 16.1. 有限状态机

```C++
const int k = 256; //字符范围
 
void buildDFA(vector<vector<int>> &dfa, const string &pat)
{
    dfa[pat[0]][0] = 1;
    for (int i = 0, j = 1; j < pat.size(); ++j)
    {
        for (int c = 0; c < k; ++c)
        {
            dfa[c][j] = dfa[c][i]; //匹配失败情况下需要将dfa[][i]复制到dfa[][j]
        }
        dfa[pat[j]][j] = j+1; //设置匹配成功情况下的值
        i = dfa[pat[j]][i];
    }
}
 
int KMP(const string &str, const string &pat)
{
    vector<vector<int>> dfa(k);
    for (auto &vec : dfa)
    {
        vec.resize(pat.size());
    }
    buildDFA(dfa, pat); //构造dfa
 
    string::size_type i, j;
    for (i = 0, j = 0; i < str.size() && j < pat.size(); ++i)
    {
        j = dfa[str[i]][j];
    }
    if (j == pat.size())
    {
        return i-pat.size();
    }
    return -1;
}
```

## 16.2. KMP

```c++
#include <bits/stdc++.h>
  
void computeLPSArray(char* pat, int M, int* lps);
  
// Prints occurrences of txt[] in pat[]
void KMPSearch(char* pat, char* txt)
{
    int M = strlen(pat);
    int N = strlen(txt);
  
    // create lps[] that will hold the longest prefix suffix
    // values for pattern
    int lps[M];
  
    // Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);
  
    int i = 0; // index for txt[]
    int j = 0; // index for pat[]
    while (i < N) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }
  
        if (j == M) {
            printf("Found pattern at index %d ", i - j);
            j = lps[j - 1];
        }
  
        // mismatch after j matches
        else if (i < N && pat[j] != txt[i]) {
            // Do not match lps[0..lps[j-1]] characters,
            // they will match anyway
            if (j != 0)
                j = lps[j - 1];
            else
                i = i + 1;
        }
    }
}
  
// Fills lps[] for given patttern pat[0..M-1]
void computeLPSArray(char* pat, int M, int* lps)
{
    // length of the previous longest prefix suffix
    int len = 0;
  
    lps[0] = 0; // lps[0] is always 0
  
    // the loop calculates lps[i] for i = 1 to M-1
    int i = 1;
    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        }
        else // (pat[i] != pat[len])
        {
            // This is tricky. Consider the example.
            // AAACAAAA and i = 7. The idea is similar
            // to search step.
            if (len != 0) {
                len = lps[len - 1];
  
                // Also, note that we do not increment
                // i here
            }
            else // if (len == 0)
            {
                lps[i] = 0;
                i++;
            }
        }
    }
}
```

# 17. 树状数组

```C++
#include <bits/stdc++.h>
using namespace std;

int n,m;
int a[50005],c[50005]; //对应原数组和树状数组

int lowbit(int x){
    return x&(-x);
}

void updata(int i,int k){    //在i位置加上k
    while(i <= n){
        c[i] += k;
        i += lowbit(i);
    }
}

int getsum(int i){        //求A[1 - i]的和
    int res = 0;
    while(i > 0){
        res += c[i];
        i -= lowbit(i);
    }
    return res;
}

int main(){
    int t;
    cin>>t;
    for(int tot = 1; tot <= t; tot++){
        cout << "Case " << tot << ":" << endl;
        memset(a, 0, sizeof a);
        memset(c, 0, sizeof c);
        cin>>n;
        for(int i = 1; i <= n; i++){
            cin>>a[i];
            updata(i,a[i]);   //输入初值的时候，也相当于更新了值
        }

        string s;
        int x,y;
        while(cin>>s && s[0] != 'E'){
            cin>>x>>y;
            if(s[0] == 'Q'){    //求和操作
                int sum = getsum(y) - getsum(x-1);    
                //x-y区间和也就等于1-y区间和减去1-(x-1)区间和
                cout << sum << endl;
            }
            else if(s[0] == 'A'){
                updata(x,y);
            }
            else if(s[0] == 'S'){
                updata(x,-y);    //减去操作，即为加上相反数
            }
        }

    }
    return 0;
}
```

# 18. 线段树

## 18.1. 定义

```C++
// 
#define maxn 100007
int A[maxn],n,N;//原数组,n为原数组元素个数 ,N为扩充元素个数 
int Sum[maxn<<2];//区间和 
int Add[maxn<<2];//懒惰标记 
```

## 18.2. 建树

```C++
//
void Build(int n){
	//计算N的值 
	N=1;while(N < n+2) N <<= 1;
	//更新叶节点 
	for(int i=1;i<=n;++i) Sum[N+i]=A[i];//原数组下标+N=存储下标
	//更新非叶节点 
	for(int i=N-1;i>0;--i){
		//更新所有非叶节点的统计信息 
		Sum[i]=Sum[i<<1]+Sum[i<<1|1];
		//清空所有非叶节点的Add标记 
		Add[i]=0;
	}
} 
```

## 18.3. 点修改

```C++
//
void Update(int L,int C){
	for(int s=N+L;s;s>>=1){
		Sum[s]+=C;
	}
} 
```

### 18.3.1. 点修改下的区间查询

```C++
//
int Query(int L,int R){
	int ANS=0;
	for(int s=N+L-1,t=N+R+1;s^t^1;s>>=1,t>>=1){
		if(~s&1) ANS+=Sum[s^1];
		if( t&1) ANS+=Sum[t^1];
	}
	return ANS;
} 
```

## 18.4. 区间修改

```C++
void Update(int L,int R,int C){
	int s,t,Ln=0,Rn=0,x=1;
	//Ln:  s一路走来已经包含了几个数
	//Rn:  t一路走来已经包含了几个数
	//x:   本层每个节点包含几个数
	for(s=N+L-1,t=N+R+1;s^t^1;s>>=1,t>>=1,x<<=1){
		//更新Sum
		Sum[s]+=C*Ln;
		Sum[t]+=C*Rn;
		//处理Add
		if(~s&1) Add[s^1]+=C,Sum[s^1]+=C*x,Ln+=x;
		if( t&1) Add[t^1]+=C,Sum[t^1]+=C*x,Rn+=x;
	}
	//更新上层Sum
	for(;s;s>>=1,t>>=1){
		Sum[s]+=C*Ln;
		Sum[t]+=C*Rn;
	} 
} 
```

### 18.4.1. 区间修改下的区间查询

```C++
//
int Query(int L,int R){
	int s,t,Ln=0,Rn=0,x=1;
	int ANS=0;
	for(s=N+L-1,t=N+R+1;s^t^1;s>>=1,t>>=1,x<<=1){
		//根据标记更新 
		if(Add[s]) ANS+=Add[s]*Ln;
		if(Add[t]) ANS+=Add[t]*Rn;
		//常规求和 
		if(~s&1) ANS+=Sum[s^1],Ln+=x;
		if( t&1) ANS+=Sum[t^1],Rn+=x; 
	}
	//处理上层标记
	for(;s;s>>=1,t>>=1){
		ANS+=Add[s]*Ln;
		ANS+=Add[t]*Rn;
	}
	return ANS;
}
```

# 19. 字符串哈希

```C++
//用跟元素个数最接近的质数作为散列表的大小
#define NHASH 29989
#define MULT 31

unsigned in hash(char *p)
{
    unsigned int h = 0;
    for (; *p; p++)
        h = MULT *h + *p;
    return h % NHASH;
}
```

# 20. 树状数组

```c++
struct Bit {
    #define Maxn 1000100
    long long val[Maxn];
    inline long long lowbit(int x) {return x & -x;}
    inline void add(int x, long long v) {while (x < Maxn) {val[x] += v; x += lowbit(x);}}
    inline long long ask(int x) {
        int res = 0; 
        while (x) {
            res += val[x];
            x -= lowbit(x);
        }
        return res;
    }
    inline long long query(int l, int r) {return ask(r) - ask(l - 1);}
} bit;
```

# 21. 旋转卡壳

```c++
// 求最远点对  
#include<iostream>  
#include<algorithm>  
#include<math.h>
using namespace std;  
int sgn(double x){
    if(fabs(x)<1e-8){
        return 0;
    }
    if(x<0){
        return -1;
    }
    return 1;
}
struct point  
{  
    double x , y;  
    bool operator<(const point& b) const{
        return sgn(x - b.x) == 0 ? sgn(y - b.y) < 0 : x < b.x;
    }
    double operator^(const point& b) const{
        return x * b.y - y * b.x;
    }
    point operator-(const point& b) const{
        point r;
        r.x = x - b.x;
        r.y = y - b.y;
        return r;
    }
}p[500005];  
  
int top , stack[500005];    // 凸包的点存在于stack[]中  
  
inline double dis(const point &a , const point &b)  
{  
    return (a.x - b.x)*(a.x - b.x)+(a.y - b.y)*(a.y - b.y);  
}
void graham(int n) //形成凸包  
{  
    sort(p ,p+n);
    int now = -1;
    for (int i = 0; i < n;++i)
    {
        while(now>0&&
            sgn((p[stack[now]]-p[stack[now-1]])^(p[i]-p[stack[now-1]]))<1){
            now--;
        }
        stack[++now] = i;
    }
    int pre = now;
    for (int i = n - 2; i >= 0;--i)
    {
        while(now>pre&&
            sgn((p[stack[now]]-p[stack[now-1]])^(p[i]-p[stack[now-1]]))<1){
            now--;
        }
        stack[++now] = i;
    }
    top = now + 1;
}  
double rotating_calipers()  //卡壳  
{  
    double ans = 0;  
    stack[top]=0;
    int now = 0;
    for(int i = 0 ; i < top ; i++)  
    {
        now = max(now,i);
        while(1){
            double k1 = dis(p[stack[i]], p[stack[now % top]]);
            double k2 = dis(p[stack[i]], p[stack[(now+1) % top]]);
            ans = max(ans, max(k1, k2));
            if(k2>k1)
                now++;
            else
                break;
        }
    } 
    return ans;  
}  
  
int main(void)  
{  
    int i , n , leftdown;   
    scanf("%d",&n); 
        for(i = 0 ; i < n ; ++i)  
        {  
            scanf("%lf %lf",&p[i].x,&p[i].y);  
        } 
        graham(n);  
        printf("%.6lf\n",sqrt(rotating_calipers()));    
    
    return 0;  
}  
```

# 22. 迪杰斯科拉

```c++
#include<bits/stdc++.h>
#define INF 3000000000000L
using namespace std;
struct star{
    vector<pair<long long,long long>> neighbourDist;
}all[200005];
int n, m;
long long calDist(int s,int t){
    priority_queue< pair<long long,long long>, 
        vector <pair<long long,long long>> , 
        greater<pair<long long,long long>> > pq;
    vector<long long> dist(n + 1, INF);
    pq.push(make_pair(0,s));
    dist[s] = 0;
    while(!pq.empty()){
        long long u = pq.top().second;
        if(u == t)
            return dist[t];
        pq.pop();
        for (auto i = all[u].neighbourDist.begin(); i != all[u].neighbourDist.end();++i)
        {
            long long v = i->first;
            long long wei = i->second;
            if(dist[v]>dist[u]+wei){
                dist[v] = dist[u] + wei;
                pq.push(make_pair(dist[v],v));
            }
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    long long p,x,y;
    cin >> n >> m;
    cin >> p >> x >> y;
    for (int i = 0; i < m;++i)
    {
        long long u,v,t;
        cin >> u >> v >> t;
        all[u].neighbourDist.push_back(pair<long long,long long>(v,t));
        all[v].neighbourDist.push_back(pair<long long,long long>(u,t));
    }
    long long px, py, xy;
    px = calDist(p, x);
    py = calDist(p, y);
    xy = calDist(y, x);
    if((px==INF)+(py==INF)+(xy==INF)>=2){
        cout << -1<<endl;
    }else{
        cout << min(px + xy, py + xy) << endl;
    }
    return 0;
}
```

# 23. 最大拓扑排序

```C++
#include<bits/stdc++.h>
using namespace std;
class node{
    public:
        int code;
        int in = 0;
        vector<node*> to;
        bool operator<(const node& b) const{
            return code < b.code;
        }
};
node all[100005];
priority_queue<node,vector<node>> top;
int main(){
    ios::sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m;++i)
    {
        int from, to;
        cin >> from >> to;
        all[from].to.push_back(all+to);
        all[to].in++;
    }
    for (int i = 1; i <= n;++i)
    {
        all[i].code = i;
        if(all[i].in == 0){
            top.push(all[i]);
        }
    }
    while(!top.empty()){
        node t = top.top();
        top.pop();
        for(node* i : t.to){
            i->in--;
            if(i->in == 0){
                top.push(*i);
            }
        }
        cout << t.code << " ";
    }
    cout<<endl;
}
```

## 23.1. 判断环路

整完了发现还有节点入度不是0，那就有环路。

# 24. 我的最大流

```c++
#include<cstdio>
#include<bits/stdc++.h>
#define min(a,b) (a<b?a:b)
using namespace std;

int head[205];
int nxt[20005];
int targ[20005];
long long weight[20005];
int depth[205];
long long ret;
int n, m, s, t;
int edgeCount =1;
void add(int from,int to, int w){
    edgeCount++;
    nxt[edgeCount] = head[from];
    weight[edgeCount] = w;
    targ[edgeCount] = to;
    head[from] = edgeCount;
    
}
void buildMap(){
    scanf("%d %d %d %d",&n,&m,&s,&t);
    for (int i = 0; i < m;++i)
    {
        int from, to, w;
        scanf("%d %d %d",&from,&to,&w);
        add(from,to,w);
        add(to,from,0);
    }
}
char splitLayers(){
    memset(depth, -1, sizeof(depth));
    depth[s] = 0;
    queue<int> bfs;
    bfs.push(s);
    while(!bfs.empty()){
        int u = bfs.front();
        bfs.pop();
        for (int i = head[u]; i;i = nxt[i])
        {
            int v = targ[i];
            if(weight[i]&&depth[v] == -1){
                bfs.push(v);
                depth[v] = depth[u] + 1;
            }
        }
    }
    if(depth[t]!=-1)
        return 1;
    return 0;
}
long long dfs(int pos,long long low){
    if(pos == t){
        return low;
    }
    long long r = 0;
    long long flow = 0;
    for (int i = head[pos]; i;i = nxt[i])
    {
        int v = targ[i];
        if(weight[i]&&depth[v] == depth[pos]+1){
            r = dfs(v,min(low,weight[i]));
            low -= r;
            flow += r;
            weight[i] -= r;
            weight[i ^ 1] += r;
            if(!low)
                break;
        }
    }
    if(!flow)
        depth[pos] = -1;
    return flow;
}
int main(){
    buildMap();
    while(splitLayers())
        ret+=dfs(s, 0xffffffff);
    
    printf("%lld",ret);
    return 0;
}
```

# 25. 波动数组

```C++
#include<stdio.h>
#include<math.h>
int nums[1005];
int ans[10005];
int main(){
    int n;
    scanf("%d",&n);
    for (int i = 0; i < n;++i)
    {
        scanf("%d",nums+i);
    }
    int ans1, ans2;
    for (int i = 0; i < n;++i)
    {
        
        int max = 0;
        int sig = 1;
        for (int j = 0; j < i;++j)
        {
            if(ans[j]<0&&nums[i]<nums[j]&&max<abs(ans[j])){
                    max = abs(ans[j]);
                    sig = 1;
            }
            if(ans[j]>0&&nums[i]>nums[j]&&max<abs(ans[j])){
                    max = abs(ans[j]);
                    sig = -1;
            }
        }
        ans[i] = (max+1)*sig;
    }
    int m = 0;
    for (int i = 0; i < n;++i){
        if(m<abs(ans[i]))
            m = abs(ans[i]);
    }
    ans1 = m;

    for (int i = 0; i < n;++i)
    {
        
        int max = 0;
        int sig = -1;
        for (int j = 0; j < i;++j)
        {
            if(ans[j]<0&&nums[i]<nums[j]&&max<abs(ans[j])){
                    max = abs(ans[j]);
                    sig = 1;
            }
            if(ans[j]>0&&nums[i]>nums[j]&&max<abs(ans[j])){
                    max = abs(ans[j]);
                    sig = -1;
            }
        }
        ans[i] = (max+1)*sig;
    }
    m = 0;
    for (int i = 0; i < n;++i){
        if(m<abs(ans[i]))
            m = abs(ans[i]);
    }
    ans2 = m;

    printf("%d", ans1>ans2?ans1:ans2);
}
```

# 26. 完全背包

```c++
#include<stdio.h>
#include<stdlib.h>
#define max(a,b) (a>b?a:b)
typedef struct pic{
    int v, w;
} pic;
pic all[1005];
long long int k, n;
long long dp[100005];
int main()
{
    scanf("%d %d",&n,&k);
    for (int i = 0; i < n;++i)
    {
        scanf("%d %d",&all[i].v,&all[i].w);
    }
    for (int i = 0; i < n;++i){
        for (int v = all[i].w;v<=k;++v)
        {
            dp[v] = max(dp[v],dp[v-all[i].w]+all[i].v);
        }
    }

        printf("%lld", dp[k]);
}
```

# 27. 最优二叉搜索树最小搜索代价

```C++
#include<stdio.h>
#define min(a,b) a<b?a:b
#define max(a,b) a>b?a:b
long long p[600];
long long f[600];
long long dp[600][600];
long long w(int i,int j){
    if(i == 0){
        return f[j] + p[j + 1];
    }
    return f[j] - f[i - 1] + p[j + 1] - p[i - 1];
}
int main(){
    int n;
    scanf("%d",&n);
    for (int i = 0; i < n;++i)
    {
        scanf("%d",f+i);
        if(i>0){
            f[i] = f[i - 1] + f[i];
        }
    }
    for (int i = 0; i <= n;++i)
    {
        scanf("%d",p+i);
        if(i>0){
            p[i] = p[i - 1] + p[i];
        }
    }
    for (int i = 0; i < n;++i)
    {
        dp[i][i] = w(i, i);
    }
    for (int l = 2; l <= n;++l)
    {
        for (int i = 0; i <= n - l;++i)
        {
            int j = i + l - 1;
            long long m = 1e15;
            for (int k = i; k <= j;++k)
            {
                long long t = dp[i][k-1] + dp[k + 1][j] + w(i,j);
                m = min(m,t);
            }
            dp[i][j] = m;
        }
    }
    printf("%lld\n",dp[0][n-1]);
    
}
```

# 28. 最长公共子序列

```C++
#include<stdio.h>
#include<string.h>
#define max(a,b) (a>b?a:b)
int bp[2005][2005];
char str1[2005];
char str2[2005];
int k;
char ret[1005];
int main(){
    scanf("%d",&k);
    scanf("%s",str1+1);
    scanf("%s",str2+1);
    int len1, len2;
    len1 = strlen(str1+1);
    len2 = strlen(str2+1);
    for (int i = 1; i <= len1;++i)
    {
        for (int j = 1; j <= len2;++j)
        {
            if(str1[i] == str2[j]){
                bp[i][j] = bp[i - 1][j - 1] + 1;
            }else{
                bp[i][j] = max(bp[i-1][j],bp[i][j-1]);
            }
        }
    }
    if(k == 0){
        printf("%d",bp[len1][len2]);
        return 0;
    }
    int m, n;
    m = len1;
    n = len2;
    
    while(bp[m][n]!=0){
        if(str1[m] == str2[n]){
            ret[bp[m][n]] = str1[m];
            m--;
            n--;
        }else{
            if(bp[m-1][n]==bp[m][n]){
                m--;
            }else{
                n--;
            }
        }
    }
    printf("%s",ret+1);
}
```
# 29. 最小生成树

## 29.1. 普利姆

```c++
#include<stdio.h>
#include<stdlib.h>
typedef struct edge{
    int w;
    int A, B;
} edge;
edge all[50005];
char in[50005];
int cmp(const void * a,const void * b){
    return *(int *)a - *(int *)b;
}
int main(){
    int n,m;
    scanf("%d %d",&n,&m);
    for (int i = 0; i < m;++i)
    {
        scanf("%d %d %d",&(all[i].A),&(all[i].B),&(all[i].w));
    }
    qsort(all,m,sizeof(edge),cmp);
    int cnt = 0;
    long long ret = 0;
    cnt++;
    in[all[0].A] = in[all[0].B] = 1;
    ret += all[0].w;
    while(cnt!=n-1){
        for (int i = 0; i < m;++i)
        {
            if(in[all[i].A]!=in[all[i].B]){
                in[all[i].A] = in[all[i].B] = 1;
                ret += all[i].w;
                cnt++;
                break;
            }
        }
    }
    printf("%lld",ret);
    return 0;
}
```
# 30. 克鲁斯卡尔
```C++
#include <bits/stdc++.h>
using namespace std;
// DSU data structure
//  path compression + rank by union
 
class DSU
{
    int *parent;
    int *rank;
 
public:
    DSU(int n)
    {
        parent = new int[n];
        rank = new int[n];
 
        for (int i = 0; i < n; i++)
        {
            parent[i] = -1;
            rank[i] = 1;
        }
    }
 
    // Find function
    int find(int i)
    {
        if (parent[i] == -1)
            return i;
 
        return parent[i] = find(parent[i]);
    }
    // union function
    void unite(int x, int y)
    {
        int s1 = find(x);
        int s2 = find(y);
 
        if (s1 != s2)
        {
            if (rank[s1] < rank[s2])
            {
                parent[s1] = s2;
                rank[s2] += rank[s1];
            }
            else
            {
                parent[s2] = s1;
                rank[s1] += rank[s2];
            }
        }
    }
};
 
class Graph
{
    vector<vector<int>> edgelist;
    int V;
 
public:
    Graph(int V)
    {
        this->V = V;
    }
 
    void addEdge(int x, int y, int w)
    {
        edgelist.push_back({w, x, y});
    }
 
    int kruskals_mst()
    {
        // 1. Sort all edges
        sort(edgelist.begin(), edgelist.end());
 
        // Initialize the DSU
        DSU s(V);
        int ans = 0;
        for (auto edge : edgelist)
        {
            int w = edge[0];
            int x = edge[1];
            int y = edge[2];
 
            // take that edge in MST if it does form a cycle
            if (s.find(x) != s.find(y))
            {
                s.unite(x, y);
                ans += w;
            }
        }
        return ans;
    }
};
int main()
{
    Graph g(4);
    g.addEdge(0, 1, 1);
    g.addEdge(1, 3, 3);
    g.addEdge(3, 2, 4);
    g.addEdge(2, 0, 2);
    g.addEdge(0, 3, 2);
    g.addEdge(1, 2, 2);
 
    // int n, m;
    // cin >> n >> m;
 
    // Graph g(n);
    // for (int i = 0; i < m; i++)
    // {
    //     int x, y, w;
    //     cin >> x >> y >> w;
    //     g.addEdge(x, y, w);
    // }
 
    cout << g.kruskals_mst();
    return 0;
}
```

# 31. 交叉线段的数量

```c++
#include <bits/stdc++.h>
using namespace std;
 
// A point in 2D plane
struct Point
{
    int x, y;
};
 
// A line segment with left as Point
// with smaller x value and right with
// larger x value.
struct Segment
{
    Point left, right;
};
 
 
// An event for sweep line algorithm
// An event has a point, the position
// of point (whether left or right) and
// index of point in the original input
// array of segments.
struct Event {
    int x, y;
    bool isLeft;
    int index;
    Event(int x, int y, bool l, int i) : x(x), y(y), isLeft(l), index(i) {}
 
    // This is for maintaining the order in set.
    bool operator<(const Event& e) const {
            if(y==e.y)return x<e.x;
            return y < e.y;
    }
};
 
 
// Given three collinear points p, q, r, the function checks if
// point q lies on line segment 'pr'
bool onSegment(Point p, Point q, Point r)
{
    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&
        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))
       return true;
 
    return false;
}
 
// To find orientation of ordered triplet (p, q, r).
// The function returns following values
// 0 --> p, q and r are collinear
// 1 --> Clockwise
// 2 --> Counterclockwise
int orientation(Point p, Point q, Point r)
{
    // See https://www.geeksforgeeks.org/orientation-3-ordered-points/
    // for details of below formula.
    int val = (q.y - p.y) * (r.x - q.x) -
              (q.x - p.x) * (r.y - q.y);
 
    if (val == 0) return 0;  // collinear
 
    return (val > 0)? 1: 2; // clock or counterclock wise
}
 
// The main function that returns true if line segment 'p1q1'
// and 'p2q2' intersect.
bool doIntersect(Segment s1, Segment s2)
{
    Point p1 = s1.left, q1 = s1.right, p2 = s2.left, q2 = s2.right;
 
    // Find the four orientations needed for general and
    // special cases
    int o1 = orientation(p1, q1, p2);
    int o2 = orientation(p1, q1, q2);
    int o3 = orientation(p2, q2, p1);
    int o4 = orientation(p2, q2, q1);
 
    // General case
    if (o1 != o2 && o3 != o4)
        return true;
 
    // Special Cases
    // p1, q1 and p2 are collinear and p2 lies on segment p1q1
    if (o1 == 0 && onSegment(p1, p2, q1)) return true;
 
    // p1, q1 and q2 are collinear and q2 lies on segment p1q1
    if (o2 == 0 && onSegment(p1, q2, q1)) return true;
 
    // p2, q2 and p1 are collinear and p1 lies on segment p2q2
    if (o3 == 0 && onSegment(p2, p1, q2)) return true;
 
     // p2, q2 and q1 are collinear and q1 lies on segment p2q2
    if (o4 == 0 && onSegment(p2, q1, q2)) return true;
 
    return false; // Doesn't fall in any of the above cases
}
 
 
// Find predecessor of iterator in s.
 set<Event>::iterator pred(set<Event> &s, set<Event>::iterator it) {
    return it == s.begin() ? s.end() : --it;
}
 
// Find successor of iterator in s.
set<Event>::iterator succ(set<Event> &s, set<Event>::iterator it) {
    return ++it;
}
 
// Returns true if any two lines intersect.
int isIntersect(Segment arr[], int n)
{
    unordered_map<string,int> mp;  
    // to note the pair for which intersection is checked already
    // Pushing all points to a vector of events
    vector<Event> e;
    for (int i = 0; i < n; ++i) {
        e.push_back(Event(arr[i].left.x, arr[i].left.y, true, i));
        e.push_back(Event(arr[i].right.x, arr[i].right.y, false, i));
    }
 
    // Sorting all events according to x coordinate.
    sort(e.begin(), e.end(), [](Event &e1, Event &e2) {return e1.x < e2.x;});
 
    // For storing active segments.
    set<Event> s;
     int ans=0;
    // Traversing through sorted points
    for (int i=0; i<2*n; i++)
    {
        Event curr = e[i];
        int index = curr.index;
 
        // If current point is left of its segment
        if (curr.isLeft)
        {
            // Get above and below points
            auto next = s.lower_bound(curr);
            auto prev = pred(s, next);
            // Check if current point intersects with
            // any of its adjacent
            bool flag=false;
            if (next != s.end() && doIntersect(arr[next->index], arr[index])){
                string s=to_string(next->index+1)+" "+to_string(index+1);
                if(mp.count(s)==0){mp[s]++;ans++;}
                 //if not already checked we can increase count in map
            }
            if (prev != s.end() && doIntersect(arr[prev->index], arr[index])){
                    string s=to_string(prev->index+1)+" "+to_string(index+1);
                if(mp.count(s)==0){mp[s]++;ans++;} 
                //if not already checked we can increase count in map
            }
            // if same line segment is there then 
            //decrease answer as it got increased twice
            if(prev != s.end() && next != s.end() && next->index==prev->index)ans--;
 
 
            // Insert current point (or event)
            s.insert(curr);
        }
 
        // If current point is right of its segment
        else
        {
            // Find the iterator
            auto it=s.find(Event(arr[index].left.x, arr[index].left.y, true, index));
            // Find above and below points
            auto next = succ(s, it);
            auto prev = pred(s, it);
 
            // If above and below point intersect
            if (next != s.end() && prev != s.end())
               {  string s=to_string(next->index+1)+" "+to_string(prev->index+1);
                    string s1=to_string(prev->index+1)+" "+to_string(next->index+1);
                   if (mp.count(s)==0&&mp.count(s1)==0&&
                    doIntersect(arr[prev->index], arr[next->index]))
                    ans++;
                    mp[s]++;
                  }
 
            // Remove current segment
            s.erase(it);
 
        }
    }
    //print pair of lines having intersection
 
    for(auto &pr:mp){
        cout<<pr.first<<"\n";
    }
    return ans;
}
 
// Driver code
int main() {
    Segment arr[] = { {{1, 5}, {4, 5}}, {{2, 5}, {10, 1}},{{3, 2}, {10, 3}},{{6, 4}, {9, 4}},{{7, 1}, {8, 1}}};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout<<isIntersect(arr, n);
    return 0;
}
```

# 32. 检查两线段是否相交

```c++

// A C++ program to check if two given line segments intersect
#include <iostream>
using namespace std;
 
struct Point
{
    int x;
    int y;
};
 
// Given three collinear points p, q, r, the function checks if
// point q lies on line segment 'pr'
bool onSegment(Point p, Point q, Point r)
{
    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&
        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))
       return true;
 
    return false;
}
 
// To find orientation of ordered triplet (p, q, r).
// The function returns following values
// 0 --> p, q and r are collinear
// 1 --> Clockwise
// 2 --> Counterclockwise
int orientation(Point p, Point q, Point r)
{
    // See https://www.geeksforgeeks.org/orientation-3-ordered-points/
    // for details of below formula.
    int val = (q.y - p.y) * (r.x - q.x) -
              (q.x - p.x) * (r.y - q.y);
 
    if (val == 0) return 0;  // collinear
 
    return (val > 0)? 1: 2; // clock or counterclock wise
}
 
// The main function that returns true if line segment 'p1q1'
// and 'p2q2' intersect.
bool doIntersect(Point p1, Point q1, Point p2, Point q2)
{
    // Find the four orientations needed for general and
    // special cases
    int o1 = orientation(p1, q1, p2);
    int o2 = orientation(p1, q1, q2);
    int o3 = orientation(p2, q2, p1);
    int o4 = orientation(p2, q2, q1);
 
    // General case
    if (o1 != o2 && o3 != o4)
        return true;
 
    // Special Cases
    // p1, q1 and p2 are collinear and p2 lies on segment p1q1
    if (o1 == 0 && onSegment(p1, p2, q1)) return true;
 
    // p1, q1 and q2 are collinear and q2 lies on segment p1q1
    if (o2 == 0 && onSegment(p1, q2, q1)) return true;
 
    // p2, q2 and p1 are collinear and p1 lies on segment p2q2
    if (o3 == 0 && onSegment(p2, p1, q2)) return true;
 
     // p2, q2 and q1 are collinear and q1 lies on segment p2q2
    if (o4 == 0 && onSegment(p2, q1, q2)) return true;
 
    return false; // Doesn't fall in any of the above cases
}
 
// Driver program to test above functions
int main()
{
    struct Point p1 = {1, 1}, q1 = {10, 1};
    struct Point p2 = {1, 2}, q2 = {10, 2};
 
    doIntersect(p1, q1, p2, q2)? cout << "Yes\n": cout << "No\n";
 
    p1 = {10, 0}, q1 = {0, 10};
    p2 = {0, 0}, q2 = {10, 10};
    doIntersect(p1, q1, p2, q2)? cout << "Yes\n": cout << "No\n";
 
    p1 = {-5, -5}, q1 = {0, 0};
    p2 = {1, 1}, q2 = {10, 10};
    doIntersect(p1, q1, p2, q2)? cout << "Yes\n": cout << "No\n";
 
    return 0;
}
```